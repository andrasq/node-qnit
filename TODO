- read cmdline options from test/qnit.opts? (like mocha, for eg -t 5000)

- setup/teardown: handle done(err) by logging error and unit test location (not "uncaught error" trace of internal location)

- report eg "var not defined" errors that occur inside tests (as opposed to MongoError: Connection Closed By Application)
  (also "call stack exceeded", which is what it was I believe)

- mocha runs each inner `describe` clause with its own copy of the surrounding scope ?!

- mocha compat: it.only to run only that test (ie, only those tagged "only")
- mocha compat: this.timeout() to control per-test timeout

- fixme: if test is ^Z suspended for more than 2000 (-t) milliseconds, the "did not call done" error is printed
  but the test is still run to completion, instead of being aborted

- mocha does not run calls below the `done()` (coculd run test in a try/catch, and throw a '__done__' flag)
- sinon compat: the returned spy is the annotated spying function, same for stub and spy (ie no spy/stub dichotomy)

- fixme: node-v6 broke --fork-files
- fixme: ifError() does not print the backtrace

- fixme: t.skip() in some cases prints 'uncaught error' but t.done() works ok
- fixme: unrequire breaks pushgateway test, but the in-lined unrequire works

- fixme: ifError() should not abort the process (should continue with the other tests)

- fixme: `throw null` is an error, but qnit thinks test succeeded!

- todo: --stack-trace-limit option to set Error.stackTraceLimit for longer backtraces (default is 10)
- todo: qnit.debug('label' [,level]) => returns a varargs console.log that prints if QNIT_DEBUG=foo,bar=2,label is set,
  else suppresses the output.  Note that leaving in debug() still spends time computing the arguments and making the call,
  but if it uses printf then could defer much of the string manipulation.
  qassert.debug? qprintf.debug? QPRINTF_DEBUG=label=2
